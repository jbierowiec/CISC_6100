<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='style.css') }}"
    />
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <title>Sudoku Game</title>
  </head>

  <body>
    <h1>Sudoku Game</h1>

    <!-- Top controls: Timer, Difficulty, and Dark/Light Mode -->
    <div class="top-controls">
      <div id="timer">00:00:00</div>
      <button id="pause-button" onclick="togglePause()">Stop</button>

      <label for="difficulty">Difficulty:</label>
      <select id="difficulty">
        <option value="easy">Easy</option>
        <option value="medium">Medium</option>
        <option value="hard">Hard</option>
      </select>

      <label for="puzzleSize">Puzzle Size:</label>
      <select id="puzzleSize">
        <option value="4">4x4</option>
        <option value="9">9x9</option>
        <option value="16">16x16</option>
      </select>

      <button onclick="toggleTheme()" id="theme-toggle">Dark Mode</button>
      <div id="mistake-counter">Mistakes: 0/3</div>
    </div>

    <!-- Displaying the Board -->
    <div id="sudoku-grid"></div>
    <div class="note-container"></div>

    <!-- Number input buttons -->
    <div class="number-controls"></div>

    <!-- Bottom controls: Check Solution, New Game, Undo, Get Hint -->
    <div class="bottom-controls">
      <button onclick="checkSolution()">Check solution</button>
      <button onclick="undoMove()">Undo</button>
      <button onclick="getHint()">Get Specific Hint</button>
      <button onclick="note()">Set Note</button>
      <button onclick="newGame()">Create new game</button>
      <button onclick="undoUntilCorrect()">Undo Until Correct</button>
      <button onclick="getRandomHint()">Get Random Hint</button>
      <button onclick="clearNotes()">Clear Note</button>
    </div>
    <!-- Loss message modal -->
    <div
      id="loss-message"
      style="
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        border: 2px solid black;
        padding: 20px;
        text-align: center;
      "
    >
      <p>You Lost!</p>
      <p>Retry in <span id="retry-timer">10</span> seconds...</p>
    </div>
    <div
      id="congrats-message"
      style="
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        border: 2px solid black;
        padding: 20px;
        text-align: center;
      "
    >
      <p>Congratulations! You have solved the Sudoku puzzle!</p>
      <button onclick="restartGame()">New Game</button>
    </div>

    <script>
      const puzzleSize = document.getElementById("puzzleSize").value;
      const maxMistakes = 3;
      let mistakeCount = 0;
      let selectedCell = null;
      let gameSolved = false;
      let moveHistory = [];
      let timerInterval;
      let seconds = 0;
      let isPaused = false;

      // Mark
      // when the html page is loaded, generate the random puzzle
      document.addEventListener("DOMContentLoaded", async function () {
        // Store the session ID in localStorage when the page loads
        currentSessionID = localStorage.getItem("session_id");
        console.log(currentSessionID);
        if (!currentSessionID)
          // if there was not an existing session, set it to 0
          currentSessionID = 0;

        // Request for a new game (pass the existing session_id if available)
        response = await fetch(`/get_session?session_id=${currentSessionID}`);
        data = await response.json();

        const newSessionID = data.new_session_id;
        console.log(newSessionID);

        localStorage.setItem("session_id", newSessionID);

        puzzleResponse = await fetch(`/get_puzzle?session_id=${newSessionID}`);
        const puzzleData = await puzzleResponse.json();

        updateGrid(puzzleData.cells);
      });

      //Jonathan & Jan
      //this is what is directly called from the button. This takes all the values we need then passes it to the async function to set the backend notes
      function note() {
        console.log(selectedCell);
        if (selectedCell) {
          const row = parseInt(selectedCell.dataset.row);
          const col = parseInt(selectedCell.dataset.col);
          const puzzleSize = parseInt(
            document.getElementById("puzzleSize").value
          );
          const gridSize = document.getElementById("puzzleSize").value; // Get the grid size dynamically
          const value = prompt(`Enter a note value (1-${gridSize}):`);
          if (value && !isNaN(value) && value >= 1 && value <= puzzleSize) {
            setNote(row, col, parseInt(value));
          } else {
            alert("Invalid note value. Please enter a valid number");
          }
        } else {
          alert("Please select a cell first.");
        }
      }

      //Jonathan
      //sets the notes in the backend then calls a function to represent this change in the front end
      async function setNote(row, col, noteValue) {
        const session_id = localStorage.getItem("session_id");
        try {
          const response = await fetch("/setNote", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              session_id: session_id,
              row: row,
              column: col,
              note_value: noteValue,
            }),
          });

          if (!response.ok) {
            throw new Error("Failed to update note in backend");
          }

          const response2 = await fetch("/getNotes", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              session_id: session_id,
              row: row,
              column: col,
            }),
          });

          const data2 = await response2.json();
          const notes = data2["notes"];
          console.log("Notes fetched successfully:", notes);
          if (notes) {
            // Call the function to update the UI with the new notes
            updateNotes(row, col, notes);
          } else {
            console.error("Cannot retrieve notes:", data.error);
          }
        } catch (error) {
          console.error("Error updating note in backend:", error);
        }
      }

      //Jonathan & Jan
      // updates the notes in the UI
      function updateNotes(row, col, notes) {
        if (!Array.isArray(notes)) {
          console.error("Invalid notes data:", notes);
          return;
        }

        const cellContainer = document.querySelector(
          `.cell-container[data-row="${row}"][data-col="${col}"]`
        );
        if (!cellContainer) {
          console.error("Cell container not found for row:", row, "col:", col);
          return;
        }

        const noteGrid = cellContainer.querySelector(".notes-grid");
        if (!noteGrid) {
          console.error(
            "Notes grid not found for cell at row:",
            row,
            "col:",
            col
          );
          return;
        }

        noteGrid.innerHTML = "";

        const gridSize = parseInt(document.getElementById("puzzleSize").value);

        let subGridSize;
        if (gridSize === 4) {
          subGridSize = 2;
        } else if (gridSize === 9) {
          subGridSize = 3;
        } else if (gridSize === 16) {
          subGridSize = 4;
        }

        noteGrid.style.display = "grid";
        noteGrid.style.gridTemplateColumns = `repeat(${subGridSize}, 1fr)`;
        noteGrid.style.gridTemplateRows = `repeat(${subGridSize}, 1fr)`;

        const cellHeight = noteGrid.clientHeight / subGridSize;
        const fontSize = Math.min(cellHeight * 0.6, 20);

        for (let note = 1; note <= gridSize; note++) {
          const noteElement = document.createElement("div");
          noteElement.classList.add("note");
          noteElement.textContent = notes.includes(note) ? note : "";
          noteElement.style.fontSize = `${fontSize}px`;
          noteElement.style.textAlign = "center";
          noteElement.style.lineHeight = `${cellHeight}px`;
          noteGrid.appendChild(noteElement);
        }

        console.log("Notes updated successfully for cell:", {
          row,
          col,
          notes,
          gridSize,
        });
      }

      //Jonathan
      //Clears all the notes both in the database and in the ui
      async function clearNotes() {
        const session_id = localStorage.getItem("session_id");

        try {
          const response = await fetch("/clearNotes", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              session_id: session_id,
            }),
          });

          if (!response.ok) {
            throw new Error("Failed to clear notes in backend");
          }

          const data = await response.json();

          if (data.success) {
            console.log(data.message);

            document
              .querySelectorAll(".cell-container")
              .forEach((cellContainer) => {
                const row = parseInt(cellContainer.dataset.row);
                const col = parseInt(cellContainer.dataset.col);

                updateNotes(row, col, []);
              });
          } else {
            console.error("Backend error:", data.error);
          }
        } catch (error) {
          console.error("Error clearing all notes:", error);
        }
      }

      // Jan
      // Function to get a hint
      function getHint() {
        if (selectedCell) {
          const row = parseInt(selectedCell.dataset.row);
          const col = parseInt(selectedCell.dataset.col);

          // Call the getSpecificHint function with the row and column
          getSpecificHint(row, col);
        } else {
          alert("Please select a cell first.");
        }
      }

      // Jonathan
      // Random Hint. Similar logic to the getHint, as now we just generate a random cell, make sure it is empty, then pass it to getSpecificHint
      function getRandomHint() {
        const size = parseInt(document.getElementById("puzzleSize").value); // Get the board size (4x4, 9x9, 16x16)

        // Ensure the grid is loaded and has cells
        const cells = document.querySelectorAll(".cell");
        if (cells.length === 0) {
          alert("The board is not ready yet.");
          return;
        }

        let row, col, cell;

        // Keep generating random rows and columns until an empty cell is found
        do {
          row = Math.floor(Math.random() * size); // Random row index
          col = Math.floor(Math.random() * size); // Random column index
          cell = document.querySelector(
            `.cell[data-row="${row}"][data-col="${col}"]`
          );
        } while (cell && (cell.value !== "" || cell.disabled)); // Ensure the cell is empty and not pre-filled

        // Pass the random row and column into getSpecificHint
        getSpecificHint(row, col);
      }

      // Jan / Jonathan
      // Function to get a specifc hint
      async function getSpecificHint(row, col) {
        try {
          // Call the backend to get the solution for the specific cell
          //fetch the sessionId from the local storage
          const sessionId = localStorage.getItem("session_id");
          if (!sessionId) {
            alert("Session ID is not available. Please restart the game.");
            return;
          }
          puzzleResponse = await fetch(`/get_puzzle?session_id=${sessionId}`);
          if (!puzzleResponse.ok) {
            throw new Error("Failed to fetch puzzle from the server");
          }
          const puzzleData = await puzzleResponse.json();
          const solution = puzzleData.solution;
          hint = solution[row][col];
          if (hint !== undefined) {
            // Fill the cell with the hint value
            const cell = document.querySelector(
              `.cell[data-row="${row}"][data-col="${col}"]`
            );
            if (cell && !cell.disabled) {
              cell.value = hint;
              alert(`Hint for cell (${row + 1}, ${col + 1}) is: ${hint}`);
            } else {
              alert("This cell is already filled or disabled.");
            }
          } else {
            alert("No hint available for this cell.");
          }
        } catch (error) {
          console.error("Error fetching hint:", error);
          alert("Unable to retrieve hint. Please try again.");
        }
      }

      // Jan
      // Function to undo the last move
      async function undoMove() {
        const sessionId = localStorage.getItem("session_id");

        if (!sessionId) {
          alert("Session ID is missing. Please restart the game.");
          return;
        }

        // Make a POST request to the Flask backend to undo the last move
        const response = await fetch("/undo", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ session_id: sessionId }),
        });

        /*const response = await fetch(`/undo?session_id=${sessionId}`, {
            method: "POST",
          });*/

        const result = await response.json();

        if (!response.ok) {
          // Handle errors returned by the backend
          alert(result.error || "An error occurred while undoing the move.");
          return;
        }

        if (result.message === "No moves left to undo") {
          alert(result.message);
          return;
        }

        // Update the cell on the frontend with the previous value
        const cell = document.querySelector(
          `.cell[data-row="${result.row}"][data-col="${result.col}"]`
        );
        if (cell) {
          cell.value = result.previous_value || ""; // Restore the cell's value
        }

        validateBoard(); // Re-validate the board after undoing the move
      }

      // Jonathan/Mark
      // Function to undo until the last correct state of the game
      async function undoUntilCorrect() {
        const sessionId = localStorage.getItem("session_id");

        if (!sessionId) {
          alert("Session ID is missing. Please restart the game.");
          return;
        }

        // Make a POST request to undo the last move
        const response = await fetch("/undo_till_correct", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ session_id: sessionId }),
        });

        const result = await response.json();

        // Iterate over the cells to update on the frontend
        result.cells_to_update.forEach((cell) => {
          const cellElement = document.querySelector(
            `.cell[data-row="${cell.row}"][data-col="${cell.col}"]`
          );

          // If the cell is found, update its value
          if (cellElement) {
            cellElement.value = cell.previous_value || ""; // Update the cell value
          }
        });

        validateBoard();

        // Reset the mistake counter
        mistakeCount = 0;
        document.getElementById(
          "mistake-counter"
        ).textContent = `Mistakes: ${mistakeCount}/3`;
      }

      document.querySelectorAll(".cell").forEach((cell) => {
        // Listen for direct keyboard input in each cell
        cell.addEventListener("input", () => {
          const row = cell.dataset.row;
          const col = cell.dataset.col;
          const newValue = cell.value;

          // Get the grid size for validation
          const gridSize = Math.sqrt(document.querySelectorAll(".cell").length);

          // Validate the input (e.g., number within range)
          if (
            newValue &&
            !isNaN(newValue) &&
            newValue >= 1 &&
            newValue <= gridSize
          ) {
            // Capture the previous value from the cell's dataset
            const previousValue = cell.dataset.previousValue || "";

            // Determine if the new value is correct
            const correct = current_solution[row][col] == newValue;

            // Add the move to the move history
            moveHistory.push({
              row: row,
              col: col,
              previousValue: previousValue,
              newValue: newValue,
              correct: correct,
            });

            console.log("Move recorded:", moveHistory);

            // Update the `previousValue` attribute for next time
            cell.dataset.previousValue = newValue;

            // Revalidate the board after the move
            validateBoard();
          } else {
            cell.value = ""; // Clear invalid input
            alert(`Please enter a number between 1 and ${gridSize}.`);
          }
        });
      });

      document.querySelectorAll(".cell").forEach((cell) => {
        // Add event listener to validate the board after each input
        cell.addEventListener("input", () => {
          validateBoard(); // Run validation after each input
        });
      });

      // Jan
      // Function to increment a mistake counter
      function incrementMistakeCounter() {
        mistakeCount++;
        document.getElementById(
          "mistake-counter"
        ).textContent = `Mistakes: ${mistakeCount}/3`;

        if (mistakeCount === maxMistakes) {
          triggerLoss();
        }
      }

      // Jan
      // Function to trigger the game lost message
      function triggerLoss() {
        // Stop the timer
        stopTimer();

        // Show the loss message
        const lossMessage = document.getElementById("loss-message");
        lossMessage.style.display = "block";

        const buttons = document.querySelectorAll("button");
        buttons.forEach((button) => {
          button.disabled = true;
        });

        // Disable board inputs
        disableBoard();

        let timer = 10; // Countdown timer
        const timerElement = document.getElementById("retry-timer");
        const interval = setInterval(() => {
          timerElement.textContent = --timer;
          if (timer === 0) {
            clearInterval(interval);

            buttons.forEach((button) => {
              button.disabled = false;
            });

            resetGameBoard();
            lossMessage.style.display = "none";
            mistakeCount = 0;
            document.getElementById(
              "mistake-counter"
            ).textContent = `Mistakes: 0/3`;
          }
        }, 1000);
      }

      // Jan
      // Function to disable the board
      function disableBoard() {
        document.querySelectorAll(".cell").forEach((cell) => {
          cell.disabled = true;
        });
      }

      // Jan
      // Function to resent the game board
      function resetGameBoard() {
        newGame();

        mistakeCount = 0;
        document.getElementById(
          "mistake-counter"
        ).textContent = `Mistakes: 0/3`;
      }

      // Jan
      // Function to validate conditions of the board
      function validateBoard() {
        const gridSize = Math.sqrt(document.querySelectorAll(".cell").length);
        const squareSize = Math.sqrt(gridSize);
        let hasMistakes = false;
        let allFilled = true;

        document.querySelectorAll(".cell").forEach((cell) => {
          cell.classList.remove("incorrect-cell"); // Remove incorrect-cell class
          cell.style.backgroundColor = ""; // Reset background color

          // Check if the board is fully filled
          if (!cell.value) {
            allFilled = false;
          }
        });

        for (let row = 0; row < gridSize; row++) {
          for (let col = 0; col < gridSize; col++) {
            const cell = document.querySelector(
              `.cell[data-row="${row}"][data-col="${col}"]`
            );
            const value = cell.value;

            if (value) {
              if (
                hasDuplicateInRow(row, col, value, gridSize) ||
                hasDuplicateInColumn(row, col, value, gridSize) ||
                hasDuplicateInSquare(row, col, value, squareSize)
              ) {
                cell.style.backgroundColor = "red";
                hasMistakes = true;
              }
            }
          }
        }

        if (!hasMistakes && allFilled) {
          checkSolutionAutomatically(); // Check solution if no mistakes and all cells are filled
        }

        if (hasMistakes) {
          incrementMistakeCounter();
        }
      }

      // Update event listeners
      document.querySelectorAll(".cell").forEach((cell) => {
        cell.addEventListener("input", () => {
          validateBoard();
        });
      });

      // Jan
      // Function to check if there is a dulicate number in a row
      function hasDuplicateInRow(row, col, value, gridSize) {
        for (let c = 0; c < gridSize; c++) {
          if (c !== col) {
            const cell = document.querySelector(
              `.cell[data-row="${row}"][data-col="${c}"]`
            );
            if (cell && cell.value === value) {
              return true;
            }
          }
        }
        return false;
      }

      // Jan
      // Function to check if there is a duplicate number in a column
      function hasDuplicateInColumn(row, col, value, gridSize) {
        for (let r = 0; r < gridSize; r++) {
          if (r !== row) {
            const cell = document.querySelector(
              `.cell[data-row="${r}"][data-col="${col}"]`
            );
            if (cell && cell.value === value) {
              return true;
            }
          }
        }
        return false;
      }

      // Jan
      // Function to check if there is a duplicate number in a 2x2, 3x3 or 4x4 square for the respective 4x4, 9x9, and 16x16 grids
      function hasDuplicateInSquare(row, col, value, squareSize) {
        const startRow = Math.floor(row / squareSize) * squareSize;
        const startCol = Math.floor(col / squareSize) * squareSize;

        for (let r = startRow; r < startRow + squareSize; r++) {
          for (let c = startCol; c < startCol + squareSize; c++) {
            if (
              (r !== row || c !== col) &&
              document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`)
                ?.value === value
            ) {
              return true;
            }
          }
        }
        return false;
      }

      document.querySelectorAll(".cell").forEach((cell) => {
        // Add event listener to enforce a single character and validate input
        cell.addEventListener("input", () => {
          const validValues = ["1", "2", "3", "4"];
          if (cell.value.length > 1 || !validValues.includes(cell.value)) {
            cell.value = ""; // Clear invalid input if length > 1 or value is not 1-4
            alert("Only values 1, 2, 3, or 4 are allowed.");
          }
        });
      });

      // Jan
      // Function to select a number from the number buttons and input it into a cell
      async function selectNumber(num) {
        if (selectedCell) {
          // Clear notes for the selected cell
          const row = parseInt(selectedCell.dataset.row);
          const col = parseInt(selectedCell.dataset.col);

          // Find the input element within the selected cell container
          const inputElement = selectedCell.querySelector("input");

          // Store the previous value of the cell before changing it
          const previousValue = inputElement.value;

          // Update the input field with the new number
          inputElement.value = num;

          userRow = selectedCell.dataset.row;
          userCol = selectedCell.dataset.col;

          // Clear notes in the backend
          const sessionId = localStorage.getItem("session_id");
          await fetch("/clearCellNotes", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ session_id: sessionId, row, column: col }),
          });

          // Clear notes in the frontend
          updateNotes(row, col, []); // Pass an empty array to clear notes

          // Get the existing session_id from localStorage
          const existingSessionId = localStorage.getItem("session_id");

          const updateResponse = await fetch("/update_cell", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              row: userRow,
              column: userCol,
              new_value: num,
              session_id: existingSessionId,
            }),
          });

          // Correct field - Jonathan
          const correctnessResponse = await fetch("/isCorrect", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              row: userRow,
              col: userCol,
              value: num,
              session_id: existingSessionId,
            }),
          });

          const result = await correctnessResponse.json();

          console.log(result.correct);
          /*
          // Record the move in the history if the previous value was empty or different
          if (!previousValue || previousValue !== num.toString()) {
            moveHistory.push({
              row: userRow,
              col: userCol,
              previousValue: previousValue, // Save the previous value for accurate undo
              newValue: num,
              correct: result.correct,
            });
          }*/

          selectedCell.classList.remove("selected"); // Deselect the cell after filling
          selectedCell = null; // Reset the selected cell

          validateBoard(); // Validate the board after filling in a number
        } else {
          alert("Please select a cell first.");
        }
      }

      //Jonathan: helper function to check if arrays are equal
      function boardsEqual(array1, array2) {
        if (array1.length !== array2.length) return false;

        for (let i = 0; i < array1.length; i++) {
          if (array1[i].length !== array2[i].length) {
            return false;
          }
          for (let j = 0; j < array1[i].length; j++) {
            if (array1[i][j] !== array2[i][j]) return false;
          }
        }
        return true;
      }

      // Jan / Jonathan / Mark
      // Function to check solution of the board
      async function checkSolution() {
        const puzzleSize = parseInt(
          document.getElementById("puzzleSize").value
        );
        const sessionId = localStorage.getItem("session_id");

        if (!sessionId) {
          alert("Session ID is not available. Please restart the game.");
          return;
        }

        // Fetch the puzzle data using the session ID
        const puzzleResponse = await fetch(
          `/get_puzzle?session_id=${sessionId}`
        );
        if (!puzzleResponse.ok) {
          alert("Failed to fetch puzzle from the server.");
          return;
        }

        const puzzleData = await puzzleResponse.json();
        const cells = puzzleData.cells; // Current state of the cells

        let allCorrect = true; // Flag to check if all cells are correct
        let boardComplete = true; // Flag to check if the board is completely filled
        let incorrectCells = []; // List to track any incorrect cells

        cells.forEach((cell) => {
          // Check only non-prefilled cells
          if (!cell.pre_filled) {
            if (cell.value === 0) {
              boardComplete = false; // Board is not complete if any cell is unfilled
            } else if (cell.value !== cell.solution) {
              allCorrect = false; // Incorrect value found
              incorrectCells.push({ row: cell.row, column: cell.column }); // Record incorrect cell
            }
          }
        });

        // Provide feedback to the user
        if (allCorrect && boardComplete) {
          alert("Sudoku has been solved!");
          stopTimer(); // Stop the timer when the solution is correct
          gameSolved = true; // Set the flag to indicate the game is solved
        } else if (!allCorrect) {
          alert("Some Entries are incorrect. Please review.");
          highlightIncorrectCells(incorrectCells); // Highlight incorrect cells
        } else if (!boardComplete) {
          alert("The puzzle is not yet complete.");
        }
      }

      async function checkSolutionAutomatically() {
        const sessionId = localStorage.getItem("session_id");

        if (!sessionId) {
          alert("Session ID is not available. Please restart the game.");
          return;
        }

        // Fetch the puzzle data using the session ID
        const puzzleResponse = await fetch(
          `/get_puzzle?session_id=${sessionId}`
        );
        if (!puzzleResponse.ok) {
          console.error("Failed to fetch puzzle data.");
          return;
        }

        const puzzleData = await puzzleResponse.json();
        const cells = puzzleData.cells;

        let allCorrect = true;

        cells.forEach((cell) => {
          if (!cell.pre_filled && cell.value !== cell.solution) {
            allCorrect = false;
          }
        });

        if (allCorrect) {
          stopTimer(); // Stop the timer
          const congratsMessage = document.getElementById("congrats-message");
          congratsMessage.style.display = "block";

          disableBoard(); // Disable the board
        }
      }

      // Mark
      // helper function to highlight incorrect cells -- NOT INVALID CELLS
      function highlightIncorrectCells(incorrectCells) {
        incorrectCells.forEach((cell) => {
          const cellElement = document.querySelector(
            `.cell[data-row="${cell.row}"][data-col="${cell.column}"]`
          );
          if (cellElement) {
            cellElement.classList.add("incorrect-cell"); // Add a CSS class for styling
          }
        });
      }

      // Jan
      // Function to load a new game on the screen
      async function newGame() {
        const difficulty = document.getElementById("difficulty").value;

        const puzzleSize = document.getElementById("puzzleSize").value; // Get the selected puzzle size

        // Get the existing session_id from localStorage if it exists
        const existingSessionId = localStorage.getItem("session_id");

        // Request for a new game (pass the existing session_id if available)
        const response = await fetch(
          `/new_game?difficulty=${difficulty}&size=${puzzleSize}&session_id=${existingSessionId}`
        );

        const { cells, session_id } = await response.json();

        // Store the new session_id in localStorage for future use
        localStorage.setItem("session_id", session_id);

        /*const response = await fetch(
          `/new_game?difficulty=${difficulty}&size=${puzzleSize}`
        );

        const { puzzle } = await response.json();*/
        console.log(session_id);
        updateGrid(cells);

        // Reset the mistake counter
        mistakeCount = 0;
        document.getElementById(
          "mistake-counter"
        ).textContent = `Mistakes: ${mistakeCount}/3`;

        resetTimer();
        moveHistory = [];
      }

      function restartGame() {
        const congratsMessage = document.getElementById("congrats-message");
        if (congratsMessage) {
          congratsMessage.style.display = "none"; // Hide the congratulations message
        }
        newGame(); // Start a new game
      }

      // Jan
      // Function to give the border colors of the grids & creating a checker pattern
      function updateBorders() {
        const isDarkMode = document.body.classList.contains("dark-mode");
        const borderColor = isDarkMode ? "rgb(255, 196, 33)" : "black";

        document.querySelectorAll(".cell").forEach((cell) => {
          const row = parseInt(cell.dataset.row);
          const col = parseInt(cell.dataset.col);
          const gridSize = Math.sqrt(document.querySelectorAll(".cell").length);

          // Determine sub-grid size
          const subGridSize = Math.sqrt(gridSize);

          // Update border colors for sub-grid separators
          if (row % subGridSize === 0) {
            cell.style.borderTop = `2px solid ${borderColor}`;
          }
          if (col % subGridSize === 0) {
            cell.style.borderLeft = `2px solid ${borderColor}`;
          }
          if ((row + 1) % subGridSize === 0) {
            cell.style.borderBottom = `2px solid ${borderColor}`;
          }
          if ((col + 1) % subGridSize === 0) {
            cell.style.borderRight = `2px solid ${borderColor}`;
          }
        });
      }

      // Jan / Mark / Jonathan
      // Function that updates the status of the grid
      function updateGrid(cells) {
        const size = Math.sqrt(cells.length); // Determines grid size (e.g., 4x4, 9x9, 16x16)
        const grid = document.getElementById("sudoku-grid");
        const cellSize = size === 16 ? "30px" : size === 9 ? "40px" : "50px";

        grid.style.gridTemplateRows = `repeat(${size}, ${cellSize})`;
        grid.style.gridTemplateColumns = `repeat(${size}, ${cellSize})`;
        grid.innerHTML = ""; // Clear the grid before updating

        // Generate cells dynamically
        cells.forEach((cell) => {
          const { row, column, value, pre_filled, notes = [] } = cell;

          // Create a container for the cell and notes
          const cellContainer = document.createElement("div");
          cellContainer.classList.add("cell-container");
          cellContainer.style.position = "relative";
          cellContainer.style.width = cellSize;
          cellContainer.style.height = cellSize;
          cellContainer.dataset.row = row;
          cellContainer.dataset.col = column;

          // Add click event listener for cell selection
          cellContainer.addEventListener("click", () => {
            // Deselect previously selected cell
            document
              .querySelectorAll(".cell-container")
              .forEach((container) => {
                container.classList.remove("selected");
              });

            // Mark the clicked cell as selected
            cellContainer.classList.add("selected");
            selectedCell = cellContainer; // Update the global `selectedCell` variable
            console.log(`Cell selected: Row ${row}, Column ${column}`);
          });

          // Create the input field for the cell
          const cellElement = document.createElement("input");
          cellElement.type = "text";
          cellElement.classList.add("cell");
          cellElement.dataset.row = row;
          cellElement.dataset.col = column;
          cellElement.value = value !== 0 ? value : ""; // Show empty for value 0
          cellElement.readOnly = true; // Prevent typing in non-pre-filled cells
          cellElement.disabled = pre_filled; // Disable pre-filled cells
          cellElement.dataset.preFilled = pre_filled ? "true" : "false"; // Mark pre-filled cells
          cellElement.style.backgroundColor = pre_filled ? "#e2e8f0" : "#fff"; // Background color
          cellElement.style.color = pre_filled ? "blue" : "#000"; // Text color
          cellElement.style.fontWeight = pre_filled ? "bold" : "normal"; // Font weight
          cellElement.style.textAlign = "center";
          cellElement.style.width = "100%";
          cellElement.style.height = "100%";

          // Allow typing directly into the cell
          cellElement.addEventListener("input", (event) => {
            console.log(
              `Cell (${row}, ${column}) updated with value: ${event.target.value}`
            );
          });

          // Prevent clicking the input from deselecting the cell
          cellElement.addEventListener("click", (event) => {
            event.stopPropagation();
          });

          // Create the notes grid (9x9 mini grid)
          const noteGrid = document.createElement("div");
          noteGrid.classList.add("notes-grid");
          noteGrid.style.display = value === 0 ? "grid" : "none"; // Show notes only if cell is empty
          noteGrid.style.gridTemplateRows = "repeat(3, 1fr)";
          noteGrid.style.gridTemplateColumns = "repeat(3, 1fr)";
          noteGrid.style.position = "absolute";
          noteGrid.style.top = "0";
          noteGrid.style.left = "0";
          noteGrid.style.width = "100%";
          noteGrid.style.height = "100%";
          noteGrid.style.pointerEvents = "none"; // Ensure notes don't block input

          // Populate the notes grid
          for (let note = 1; note <= 9; note++) {
            const noteElement = document.createElement("div");
            noteElement.classList.add("note");
            noteElement.style.fontSize = "8px";
            noteElement.style.textAlign = "center";
            noteElement.style.lineHeight = `${parseInt(cellSize) / 3}px`;
            noteElement.textContent = notes.includes(note) ? note : ""; // Display note if it exists
            noteGrid.appendChild(noteElement);
          }

          // Append the cell and notes grid to the container
          cellContainer.appendChild(cellElement);
          cellContainer.appendChild(noteGrid);

          // Append the container to the grid
          grid.appendChild(cellContainer);
        });

        // Reset move history and other settings
        moveHistory = [];
        updateNumberButtons(size);
        updateBorders();
      }

      // Jan
      // Function to generate number buttons based on the grid size
      function updateNumberButtons(size) {
        const buttonContainer = document.querySelector(".number-controls");
        buttonContainer.innerHTML = ""; // Clear existing buttons

        // Determine the range of numbers based on grid size
        const maxNumber = size === 16 ? 16 : size === 9 ? 9 : 4;

        // Generate buttons from 1 to maxNumber
        for (let i = 1; i <= maxNumber; i++) {
          const button = document.createElement("button");
          button.textContent = i;
          button.onclick = () => selectNumber(i); // Assign the number when clicked
          buttonContainer.appendChild(button);
        }
      }

      // Jan
      // Function to pause the game
      function togglePause() {
        const pauseButton = document.getElementById("pause-button");
        const cells = document.querySelectorAll(".cell");
        const buttons = document.querySelectorAll("button");

        if (isPaused) {
          // Resume the game
          pauseButton.textContent = "Stop";

          // Restore the original state of all cells
          cells.forEach((cell) => {
            //cell.style.backgroundColor = "#ccc"; // Restore cell background
            //cell.style.color = ""; // Restore cell text color
            //cell.style.filter = ""; // Remove blur
            //cell.disabled = cell.dataset.pre_filled === "true"; // Disable pre-filled cells

            const isPreFilled = cell.dataset.preFilled === "true";

            if (isPreFilled) {
              // Reapply pre-filled cell styles
              cell.style.backgroundColor = "#e2e8f0"; // Light blue background
              cell.style.color = "blue"; // Blue text
              cell.style.fontWeight = "bold"; // Bold font
              cell.disabled = true; // Pre-filled cells remain disabled
            } else {
              // Restore user-input cell styles
              cell.style.backgroundColor = "#fff"; // White background
              cell.style.color = "#000"; // Black text
              cell.style.fontWeight = "normal"; // Normal font
              cell.disabled = false; // Enable user-input cells
            }

            // Remove blur effect
            cell.style.filter = "";
          });

          // Enable all buttons except the pause button
          buttons.forEach((button) => {
            button.disabled = false;
          });

          startTimer(); // Resume the timer
          isPaused = false;
        } else if (!isPaused) {
          // Pause the game
          pauseButton.textContent = "Play";

          // Blur all cells
          cells.forEach((cell) => {
            cell.style.filter = "blur(5px)"; // Apply blur
            cell.disabled = true; // Disable all interactions
          });

          // Disable all buttons except the pause button
          buttons.forEach((button) => {
            if (button.id !== "pause-button") {
              button.disabled = true;
            }
          });

          stopTimer(); // Pause the timer
          isPaused = true;
        }
      }

      // Jan
      // Function to start the timer
      function startTimer() {
        clearInterval(timerInterval); // Ensure no duplicate intervals
        timerInterval = setInterval(() => {
          seconds++;
          document.getElementById("timer").textContent = formatTime(seconds);
        }, 1000);
      }

      // Jan
      // Function to stop the timer
      function stopTimer() {
        clearInterval(timerInterval);
      }

      // Jan
      // Function to reset the timer
      function resetTimer() {
        clearInterval(timerInterval);
        seconds = 0;
        document.getElementById("timer").textContent = formatTime(seconds);
        gameSolved = false; // Reset the solved flag when a new game starts
        startTimer();
      }

      // Jan
      // Helper function to format time in HH:MM:SS format
      function formatTime(totalSeconds) {
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(
          2,
          "0"
        )}:${String(seconds).padStart(2, "0")}`;
      }

      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          // Tab becomes inactive
          if (!isPaused) {
            stopTimer(); // Stop the timer if the game is not paused
          }
        } else {
          // Tab becomes active again
          if (!isPaused) {
            startTimer(); // Resume the timer only if the game is not paused
          }
        }
      });

      // Jan
      // Light & Dark Mode Button Functionality
      function toggleTheme() {
        const body = document.body;
        const themeToggleButton = document.getElementById("theme-toggle");

        // Toggle the dark-mode class on the body
        body.classList.toggle("dark-mode");

        // Update the button text based on the current theme
        if (body.classList.contains("dark-mode")) {
          themeToggleButton.textContent = "Light Mode";
          localStorage.setItem("theme", "dark");
        } else {
          themeToggleButton.textContent = "Dark Mode";
          localStorage.setItem("theme", "light");
        }

        updateBorders();
      }

      // Jan
      // Function to enforece the input of a cell to be only one value
      function enforceMaxLength() {
        const cells = document.querySelectorAll(".cell"); // Select all input cells
        cells.forEach((cell) => {
          cell.setAttribute("maxlength", "1"); // Enforce maxlength
        });
      }

      // Start the timer when the window loads
      window.onload = () => {
        enforceMaxLength();
        if (localStorage.getItem("theme") === "dark") {
          document.body.classList.add("dark-mode");
          document.getElementById("theme-toggle").textContent = "Light Mode";
        } else {
          document.body.classList.add("light-mode");
          document.getElementById("theme-toggle").textContent = "Dark Mode";
        }
        startTimer();
      };
    </script>
  </body>
</html>
