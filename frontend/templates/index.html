<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='style.css') }}"
    />
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <title>Sudoku Game</title>
  </head>

  <body onload="updateGrid({{ puzzle|tojson }});">
    <h1>Sudoku Game</h1>

    <!-- Top controls: Timer, Difficulty, and Dark/Light Mode -->
    <div class="top-controls">
      <div id="timer">00:00:00</div>

      <label for="difficulty">Difficulty:</label>
      <select id="difficulty">
        <option value="easy">Easy</option>
        <option value="medium">Medium</option>
        <option value="hard">Hard</option>
      </select>

      <label for="puzzleSize">Puzzle Size:</label>
      <select id="puzzleSize">
        <option value="4">4x4</option>
        <option value="9">9x9</option>
        <option value="16">16x16</option>
      </select>

      <button onclick="toggleTheme()" id="theme-toggle">Dark Mode</button>
    </div>

    <!-- Displaying the Board -->
    <div id="sudoku-grid"></div>
    <div class="note-container"></div>

    <!-- maxlength="1" oninput="validateInput(this)"  -->

    <!-- Number input buttons -->
    <div class="number-controls"></div>

    <!-- Bottom controls: Check Solution, New Game, Undo -->
    <div class="bottom-controls">
      <button onclick="checkSolution()">Check solution</button>
      <button onclick="newGame()">Create new game</button>
      <button onclick="undoMove()">Undo</button>
      <button onclick="undoUntilCorrect()">Undo Until Correct</button>
    </div>

    <script>
      const puzzleSize = document.getElementById("puzzleSize").value;

      // Function to undo the last move
      function undoMove() {
        if (moveHistory.length === 0) {
          alert("No moves to undo.");
          return;
        }

        // Get the last move from the history
        const lastMove = moveHistory.pop();

        // Find the cell and set it back to empty
        const cell = document.querySelector(
          `.cell[data-row="${lastMove.row}"][data-col="${lastMove.col}"]`
        );
        if (cell) {
          cell.value = lastMove.previousValue || ""; // Clear the cell's value
        }

        validateBoard(); // Re-validate the board after undoing the move
      }

      function undoUntilCorrect() {
        if (moveHistory.length === 0) {
          alert("No moves to undo.");
          return;
        }

        // Filter out moves where `correct` is false
        for (let i = moveHistory.length - 1; i >= 0; i--) {
          if (moveHistory[i].correct === false) {
            const move = moveHistory[i];

            // Update the game board based on the move
            const cell = document.querySelector(
              `.cell[data-row="${move.row}"][data-col="${move.col}"]`
            );
            if (cell) {
              cell.value = move.previousValue || ""; // Reset the cell to its previous value
            }

            // Remove the entry from moveHistory
            moveHistory.splice(i, 1);

            validateBoard();
          }
        }
      }

      document.querySelectorAll(".cell").forEach((cell) => {
        // Listen for direct keyboard input in each cell
        cell.addEventListener("input", () => {
          const row = cell.dataset.row;
          const col = cell.dataset.col;
          const newValue = cell.value;

          // Only record if the input is a valid number between 1 and 4
          if (["1", "2", "3", "4"].includes(newValue)) {
            // Get the previous value before updating it
            const previousValue = cell.dataset.previousValue || "";

            const correct = current_solution[row][col] == newValue;

            // Record the move
            moveHistory.push({
              row: row,
              col: col,
              previousValue: previousValue, // Store the previous value
              newValue: newValue,
              correct: correct, //add a correct field so we can easily check if a move is correct
            });
            console.log("move made");

            // Update `previousValue` data attribute to the current value for next time
            cell.dataset.previousValue = newValue;

            validateBoard(); // Re-validate the board after each input
          } else {
            cell.value = ""; // Clear invalid input
            alert("Only values 1, 2, 3, or 4 are allowed.");
          }
        });
      });

      document.querySelectorAll(".cell").forEach((cell) => {
        // Add event listener to validate the board after each input
        cell.addEventListener("input", () => {
          validateBoard(); // Run validation after each input
        });
      });

      function validateBoard() {
        const gridSize = document.querySelectorAll(".cell").length ** 0.5;
        const squareSize = Math.sqrt(gridSize);

        document.querySelectorAll(".cell").forEach((cell) => {
          cell.style.backgroundColor = ""; // Reset background color
        });

        for (let row = 0; row < gridSize; row++) {
          for (let col = 0; col < gridSize; col++) {
            const cell = document.querySelector(
              `.cell[data-row="${row}"][data-col="${col}"]`
            );
            const value = cell.value;

            if (value) {
              if (
                hasDuplicateInRow(row, col, value, gridSize) ||
                hasDuplicateInColumn(row, col, value, gridSize) ||
                hasDuplicateInSquare(row, col, value, squareSize)
              ) {
                cell.style.backgroundColor = "red";
              }
            }
          }
        }
      }

      function hasDuplicateInRow(row, col, value, gridSize) {
        for (let c = 0; c < gridSize; c++) {
          if (c !== col) {
            const cell = document.querySelector(
              `.cell[data-row="${row}"][data-col="${c}"]`
            );
            if (cell && cell.value === value) {
              return true;
            }
          }
        }
        return false;
      }

      function hasDuplicateInColumn(row, col, value, gridSize) {
        for (let r = 0; r < gridSize; r++) {
          if (r !== row) {
            const cell = document.querySelector(
              `.cell[data-row="${r}"][data-col="${col}"]`
            );
            if (cell && cell.value === value) {
              return true;
            }
          }
        }
        return false;
      }

      function hasDuplicateInSquare(row, col, value, squareSize) {
        const startRow = Math.floor(row / squareSize) * squareSize;
        const startCol = Math.floor(col / squareSize) * squareSize;

        for (let r = startRow; r < startRow + squareSize; r++) {
          for (let c = startCol; c < startCol + squareSize; c++) {
            if (
              (r !== row || c !== col) &&
              document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`)
                ?.value === value
            ) {
              return true;
            }
          }
        }
        return false;
      }

      let selectedCell = null;

      document.querySelectorAll(".cell").forEach((cell) => {
        // Add event listener to enforce a single character and validate input
        cell.addEventListener("input", () => {
          const validValues = ["1", "2", "3", "4"];
          if (cell.value.length > 1 || !validValues.includes(cell.value)) {
            cell.value = ""; // Clear invalid input if length > 1 or value is not 1-4
            alert("Only values 1, 2, 3, or 4 are allowed.");
          }
        });
      });

      function selectNumber(num) {
        if (selectedCell) {
          //selectedCell.value = num;
          // Store the previous value of the cell before changing it
          const previousValue = selectedCell.value;

          // Update the cell with the new number
          selectedCell.value = num;

          // Record the move in the history if the previous value was empty or different
          if (!previousValue || previousValue !== num.toString()) {
            moveHistory.push({
              row: selectedCell.dataset.row,
              col: selectedCell.dataset.col,
              previousValue: previousValue, // Save the previous value for accurate undo
              newValue: num,
            });
          }

          selectedCell.classList.remove("selected"); // Deselect the cell after filling
          selectedCell = null; // Reset the selected cell

          validateBoard(); // Validate the board after filling in a number
        } else {
          alert("Please select a cell first.");
        }
      }

      let gameSolved = false; // Flag to track if the game is solved
      let moveHistory = [];

      async function checkSolution() {
        const solution = [];

        for (let i = 0; i < 4; i++) {
          const row = [];
          for (let j = 0; j < 4; j++) {
            const cell = document.querySelector(
              `.cell[data-row="${i}"][data-col="${j}"]`
            );
            if (cell) {
              const value = parseInt(cell.value) || 0;
              row.push(value);
            } else {
              row.push(0);
            }
          }
          solution.push(row);
        }

        const response = await fetch("/check_solution", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ solution: solution }),
        });

        const result = await response.json();

        if (result.status === "correct") {
          alert("Sudoku has been solved!");
          stopTimer(); // Stop the timer when the solution is correct
          gameSolved = true; // Set the flag to indicate the game is solved
        } else {
          alert("Incorrect solution.");
        }
      }

      async function newGame() {
        const difficulty = document.getElementById("difficulty").value;

        const puzzleSize = document.getElementById("puzzleSize").value; // Get the selected puzzle size

        const response = await fetch(
          `/new_game?difficulty=${difficulty}&size=${puzzleSize}`
        );

        const { puzzle } = await response.json();
        console.log(puzzle);
        updateGrid(puzzle);
        resetTimer();
        moveHistory = [];
      }

      function updateGrid(puzzle) {
        const size = puzzle.length;
        const grid = document.getElementById("sudoku-grid");

        const cellSize = size === 16 ? "30px" : size === 9 ? "40px" : "50px"; // Adjust cell size based on grid size

        // Sets up CSS grid with the appropriate size
        grid.style.gridTemplateRows = `repeat(${size}, ${cellSize})`;
        grid.style.gridTemplateColumns = `repeat(${size}, ${cellSize})`;
        grid.innerHTML = ""; // Clear existing grid

        // Generate cells dynamically
        for (let row = 0; row < size; row++) {
          for (let col = 0; col < size; col++) {
            const cell = document.createElement("input");
            cell.type = "text";
            cell.classList.add("cell");
            cell.dataset.row = row;
            cell.dataset.col = col;
            cell.value = puzzle[row][col] || ""; // Empty for unfilled cells
            cell.disabled = !!puzzle[row][col]; // Disable pre-filled cells
            cell.style.textAlign = "center";
            cell.style.width = cellSize;
            cell.style.height = cellSize;
            grid.appendChild(cell);
          }
        }
        moveHistory = []; // Reset move history

        // Adjust number buttons based on grid size
        updateNumberButtons(size);
        // Function to handle cell selection (remains largely the same)
        document.querySelectorAll(".cell").forEach((cell) => {
          cell.addEventListener("click", () => {
            // Deselect previously selected cell, if any
            document
              .querySelectorAll(".cell")
              .forEach((c) => c.classList.remove("selected"));
            // Mark the clicked cell as selected
            cell.classList.add("selected");
            selectedCell = cell;
          });
        });
      }
      // Function to generate number buttons based on the grid size
      function updateNumberButtons(size) {
        const buttonContainer = document.querySelector(".number-controls");
        buttonContainer.innerHTML = ""; // Clear existing buttons

        // Determine the range of numbers based on grid size
        const maxNumber = size === 16 ? 16 : size === 9 ? 9 : 4;

        // Generate buttons from 1 to maxNumber
        for (let i = 1; i <= maxNumber; i++) {
          const button = document.createElement("button");
          button.textContent = i;
          button.onclick = () => selectNumber(i); // Assign the number when clicked
          buttonContainer.appendChild(button);
        }
      }

      // Timer Functions Setup
      let timerInterval;
      let seconds = 0;

      // Function to start the timer
      function startTimer() {
        clearInterval(timerInterval); // clears any existing timer
        timerInterval = setInterval(() => {
          seconds++;
          document.getElementById("timer").textContent = formatTime(seconds);
        }, 1000);
      }

      // Function to stop the timer
      function stopTimer() {
        clearInterval(timerInterval);
      }

      // Function to reset the timer
      function resetTimer() {
        clearInterval(timerInterval);
        seconds = 0;
        document.getElementById("timer").textContent = formatTime(seconds);
        gameSolved = false; // Reset the solved flag when a new game starts
        startTimer();
      }

      // Helper function to format time in HH:MM:SS format
      function formatTime(totalSeconds) {
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(
          2,
          "0"
        )}:${String(seconds).padStart(2, "0")}`;
      }

      // Event listener to pause/resume timer on tab visibility change
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          // Stop the timer when the tab is not active
          stopTimer();
        } else if (!gameSolved) {
          // Resume the timer when the tab becomes active again
          startTimer();
        }
      });

      // Light & Dark Mode Button Functionality
      function toggleTheme() {
        const body = document.body;
        const themeToggleButton = document.getElementById("theme-toggle");

        // Toggle the dark-mode class on the body
        body.classList.toggle("dark-mode");

        // Update the button text based on the current theme
        if (body.classList.contains("dark-mode")) {
          themeToggleButton.textContent = "Light Mode";
          localStorage.setItem("theme", "dark");
        } else {
          themeToggleButton.textContent = "Dark Mode";
          localStorage.setItem("theme", "light");
        }
      }

      // Start the timer when the window loads
      window.onload = () => {
        if (localStorage.getItem("theme") === "dark") {
          document.body.classList.add("dark-mode");
          document.getElementById("theme-toggle").textContent = "Light Mode";
        } else {
          document.body.classList.add("light-mode");
          document.getElementById("theme-toggle").textContent = "Dark Mode";
        }
        startTimer();
      };
    </script>
  </body>
</html>
