<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='style.css') }}"
    />
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <title>Sudoku Game</title>
  </head>

  <body>
    <h1>Sudoku Game</h1>

    <!-- Top Button Controls: Timer, Difficulty, Size, and Dark/Light Mode -->
    <div class="top-controls">
      <div id="timer">00:00:00</div>
      <button id="pause-button" onclick="togglePause()">Stop</button>

      <label for="difficulty">Difficulty:</label>
      <select id="difficulty">
        <option value="easy" selected>Easy</option>
        <option value="medium">Medium</option>
        <option value="hard">Hard</option>
      </select>

      <label for="puzzleSize">Puzzle Size:</label>
      <select id="puzzleSize">
        <option value="4" selected>4x4</option>
        <option value="9">9x9</option>
        <option value="16">16x16</option>
      </select>

      <button onclick="toggleTheme()" id="theme-toggle">Dark Mode</button>
      <div id="mistake-counter">Mistakes: 0/3</div>
    </div>

    <!-- Displaying the Board -->
    <div id="sudoku-grid"></div>
    <div class="note-container"></div>

    <!-- Number input buttons -->
    <div class="number-controls"></div>

    <!-- Bottom Button Controls: Undo/Undo Until Correct, Set Note/Check Solution/New Game, Get Specific Hint/Get Random Hint -->
    <div class="bottom-controls">
      <div class="button-column">
        <button onclick="undoMove()" style="grid-row: span 2">Undo Move</button>
        <button onclick="undoUntilCorrect()">Undo Until Correct</button>
      </div>
      <div class="button-column">
        <!--<button onclick="toggleSetNote()">Set Note: Off</button>-->
        <button onclick="checkSolution()">Check Solution</button>
        <button onclick="newGame()">New Game</button>
      </div>
      <div class="button-column">
        <button onclick="getHint()">Get Specific Hint</button>
        <!--<button onclick="getRandomHint()">Get Random Hint</button>-->
      </div>
    </div>

    <!-- Loss message modal -->
    <div
      id="loss-message"
      style="
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        border: 2px solid black;
        padding: 20px;
        text-align: center;
      "
    >
      <p>You Lost!</p>
      <p>Retry in <span id="retry-timer">10</span> seconds...</p>
    </div>

    <script>
      /* VARIABLE DECLARATIONS */

      const maxMistakes = 3; // maximum mistakes that the user can make with respect to having a value in the same square, row, or column
      let mistakeCount = 0; // mistake counter starts with 0
      let selectedCell = null; // a selected cell has an initial value of null
      let gameSolved = false; // every game starts out with a condition of not being solved
      let moveHistory = []; // move history array
      let timerInterval; // time interval variable
      let seconds = 0; // seconds set to 0
      let isPaused = false; // games start with time not paused
      newGame(); // a game is displayed on the screen by default as opposed to just the buttons

      /* GAME BUTTONS */

      // Jan
      // Function to undo the last move
      function undoMove() {
        if (moveHistory.length === 0) {
          alert("No moves to undo.");
          return;
        }

        const lastMove = moveHistory.pop(); // remove moves made by the user from the moveHistory array
        const cell = document.querySelector(
          `.cell[data-row="${lastMove.row}"][data-col="${lastMove.col}"]`
        );
        if (cell) {
          cell.value = lastMove.previousValue || ""; // replace a cell with an inputed value to be set to nothing
        }

        validateBoard();
      }

      // Jonathan
      // Function to undo until the last correct state of the game
      async function undoUntilCorrect() {
        const response = await fetch(`/undoUntilCorrect`, {
          method: "POST", // use the POST method
          headers: {
            "Content-Type": "application/json", // include the Content-Type header
          },
          body: JSON.stringify({}),
        });

        const data = await response.json();
        const first_wrong = data.index;
        const puzzle = data.puzzle;
        console.log(puzzle);
        updateGrid(puzzle);

        for (
          // for loop looping through the length of the moveHistory array and finding the first incorrect value
          let index = moveHistory.length - 1;
          index >= first_wrong;
          index--
        ) {
          moveHistory.pop();
        }

        mistakeCount = 0; // reset the mistake counter
        document.getElementById(
          "mistake-counter"
        ).textContent = `Mistakes: ${mistakeCount}/3`;
      }

      /* TODO: SET NOTE MODE BUTTON */

      // Jan
      // Function to check solution of the board
      async function checkSolution() {
        const puzzleSize = parseInt(
          document.getElementById("puzzleSize").value
        );
        const solution = [];

        for (let i = 0; i < puzzleSize; i++) {
          // for loops looping through the size of the puzzle, and recording the inputs the user makes
          const row = [];
          for (let j = 0; j < puzzleSize; j++) {
            const cell = document.querySelector(
              `.cell[data-row="${i}"][data-col="${j}"]`
            );
            if (cell) {
              const value = parseInt(cell.value) || 0;
              row.push(value);
            } else {
              row.push(0);
            }
          }
          solution.push(row);
        }

        const response = await fetch("/check_solution", {
          // call check_solution to check if the solution from the backend data matches all the user inputs
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ solution: solution }),
        });

        const result = await response.json();

        if (result.status === "correct") {
          alert("Sudoku has been solved!");
          stopTimer(); // stop the timer when the solution is correct
          gameSolved = true; // set the flag to indicate the game is solved
        } else {
          alert("Incorrect solution.");
        }
      }

      // when the html page is loaded, generate the random puzzle
      document.addEventListener("DOMContentLoaded", function() {
          // Store the session ID in localStorage when the page loads
          sessionID = "{{ sessionID }}";  // Use the sessionID passed from Flask
          console.log(sessionID);
          localStorage.setItem("session_id", sessionID);
        
          updateGrid({{ puzzle|tojson }}); 
      });
  
      // Jan
      // Function to get a hint
      function getHint() {
        if (selectedCell) {
          const row = parseInt(selectedCell.dataset.row);
          const col = parseInt(selectedCell.dataset.col);

          getSpecificHint(row, col);
        } else {
          alert("Please select a cell first.");
        }
      }

      // Jan
      // Function to get a specifc hint
      async function getSpecificHint(row, col) {
        try {
          const response = await fetch(`/get_hint`, {
            // call get hint from the backend
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ row: row, col: col }),
          });

          if (!response.ok) {
            throw new Error("Failed to fetch hint from the server");
          }

          const result = await response.json();

          if (result.hint !== undefined) {
            // logic to check if cell is prefilled/empty/or if no hint is available
            const cell = document.querySelector(
              `.cell[data-row="${row}"][data-col="${col}"]`
            );
            if (cell && !cell.disabled) {
              cell.value = result.hint;
              alert(
                `Hint for cell (${row + 1}, ${col + 1}) is: ${result.hint}`
              );
            } else {
              alert("This cell is already filled or disabled.");
            }
          } else {
            alert("No hint available for this cell.");
          }
        } catch (error) {
          console.error("Error fetching hint:", error);
          alert("Unable to retrieve hint. Please try again.");
        }
      }

      /* TODO: GET RANDOM HINT BUTTON */

      /* FUNCTIONS TO VALIDATE THE BOARD */

      // Jan
      // Function to validate conditions of the board based on smaller squares, rows and columns
      function validateBoard() {
        const gridSize = Math.sqrt(document.querySelectorAll(".cell").length);
        const squareSize = Math.sqrt(gridSize);
        let hasMistakes = false;

        document.querySelectorAll(".cell").forEach((cell) => {
          cell.style.backgroundColor = ""; // Reset background color
        });

        for (let row = 0; row < gridSize; row++) {
          for (let col = 0; col < gridSize; col++) {
            const cell = document.querySelector(
              `.cell[data-row="${row}"][data-col="${col}"]`
            );
            const value = cell.value;

            if (value) {
              if (
                // calls helper functions to validate the board
                hasDuplicateInRow(row, col, value, gridSize) ||
                hasDuplicateInColumn(row, col, value, gridSize) ||
                hasDuplicateInSquare(row, col, value, squareSize)
              ) {
                cell.style.backgroundColor = "red";
                hasMistakes = true;
              }
            }
          }
        }

        if (hasMistakes) {
          // if there are mistakes then the mistake counter is incremented
          incrementMistakeCounter();
        }
      }

      // Jan
      // Function to check if there is a dulicate number in a row
      function hasDuplicateInRow(row, col, value, gridSize) {
        for (let c = 0; c < gridSize; c++) {
          if (c !== col) {
            const cell = document.querySelector(
              `.cell[data-row="${row}"][data-col="${c}"]`
            );
            if (cell && cell.value === value) {
              return true;
            }
          }
        }
        return false;
      }

      // Jan
      // Function to check if there is a duplicate number in a column
      function hasDuplicateInColumn(row, col, value, gridSize) {
        for (let r = 0; r < gridSize; r++) {
          if (r !== row) {
            const cell = document.querySelector(
              `.cell[data-row="${r}"][data-col="${col}"]`
            );
            if (cell && cell.value === value) {
              return true;
            }
          }
        }
        return false;
      }

      // Jan
      // Function to check if there is a duplicate number in a 2x2, 3x3 or 4x4 square for the respective 4x4, 9x9, and 16x16 grids
      function hasDuplicateInSquare(row, col, value, squareSize) {
        const startRow = Math.floor(row / squareSize) * squareSize;
        const startCol = Math.floor(col / squareSize) * squareSize;

        for (let r = startRow; r < startRow + squareSize; r++) {
          for (let c = startCol; c < startCol + squareSize; c++) {
            if (
              (r !== row || c !== col) &&
              document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`)
                ?.value === value
            ) {
              return true;
            }
          }
        }
        return false;
      }

      /* TIMER FUNCTIONS */

      // Jan
      // Function to pause the game
      function togglePause() {
        const pauseButton = document.getElementById("pause-button");
        const cells = document.querySelectorAll(".cell");
        const buttons = document.querySelectorAll("button");

        if (isPaused) {
          // isPaused is false by default
          pauseButton.textContent = "Stop"; // resume the game

          cells.forEach((cell) => {
            cell.style.filter = ""; // remove blur
            cell.disabled = cell.dataset.preFilled === "true"; // disable only pre-filled cells
          });

          buttons.forEach((button) => {
            // enable all buttons except the pause button condition
            button.disabled = false;
          });

          startTimer(); // resume the timer
          isPaused = false;
        } else if (!isPaused) {
          pauseButton.textContent = "Play"; // pause the game

          cells.forEach((cell) => {
            cell.style.filter = "blur(5px)"; // apply blur
            cell.disabled = true; // disable all cell interactions
          });

          buttons.forEach((button) => {
            // disable all buttons except the pause button
            if (button.id !== "pause-button") {
              button.disabled = true;
            }
          });

          stopTimer(); // pause the timer
          isPaused = true;
        }
      }

      // Jan
      // Function to start the timer
      function startTimer() {
        clearInterval(timerInterval); // ensures no duplicate intervals
        timerInterval = setInterval(() => {
          seconds++;
          document.getElementById("timer").textContent = formatTime(seconds);
        }, 1000);
      }

      // Jan
      // Function to stop the timer
      function stopTimer() {
        clearInterval(timerInterval);
      }

      // Jan
      // Function to reset the timer
      function resetTimer() {
        clearInterval(timerInterval);
        seconds = 0;
        document.getElementById("timer").textContent = formatTime(seconds);
        gameSolved = false; // reset the solved flag when a new game starts
        startTimer();
      }

      // Jan
      // Helper function to format time in HH:MM:SS format
      function formatTime(totalSeconds) {
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(
          2,
          "0"
        )}:${String(seconds).padStart(2, "0")}`;
      }

      /* MISTAKE COUNTER & LOSE PAGE FUNCTIONS */

      // Jan
      // Function to increment a mistake counter
      function incrementMistakeCounter() {
        mistakeCount++;
        document.getElementById(
          "mistake-counter"
        ).textContent = `Mistakes: ${mistakeCount}/3`;

        if (mistakeCount === maxMistakes) {
          // if mistake count is the same number as the maximum mistakes then a loss is triggered
          triggerLoss();
        }
      }

      // Jan
      // Function to trigger the game lost message
      function triggerLoss() {
        stopTimer(); // stop the timer

        const lossMessage = document.getElementById("loss-message"); // loss message displayed on the screen
        lossMessage.style.display = "block";

        const buttons = document.querySelectorAll("button");
        buttons.forEach((button) => {
          button.disabled = true; // all buttons are disabled on the screen
        });

        disableBoard(); // board inputs are disabled

        let timer = 10; // countdown timer set to 10 seconds enforcing the user to wait
        const timerElement = document.getElementById("retry-timer");
        const interval = setInterval(() => {
          timerElement.textContent = --timer;
          if (timer === 0) {
            // all buttons are unabled, the game board is reset, mistake count is reset to 0
            clearInterval(interval);

            buttons.forEach((button) => {
              button.disabled = false;
            });

            resetGameBoard();
            lossMessage.style.display = "none";
            mistakeCount = 0;
            document.getElementById(
              "mistake-counter"
            ).textContent = `Mistakes: 0/3`;
          }
        }, 1000);
      }

      /* SUPPLEMENTARY FUNCTIONS FOR THE FRONTEND OF THE GAME */

      // Jan
      // Function to disable the board
      function disableBoard() {
        document.querySelectorAll(".cell").forEach((cell) => {
          cell.disabled = true;
        });
      }

      // Jan
      // Function to reset the game board
      function resetGameBoard() {
        newGame();

        mistakeCount = 0;
        document.getElementById(
          "mistake-counter"
        ).textContent = `Mistakes: 0/3`;
      }

      // Jan
      // Function to select a number from the number buttons and input it into a cell
      async function selectNumber(num) {
        if (selectedCell) {
          const previousValue = selectedCell.value; // store the previous value of the cell before changing it

          selectedCell.value = num; // update the cell with the new number
          userRow = selectedCell.dataset.row;
          userCol = selectedCell.dataset.col;

          const response = await fetch("/isCorrect", {
            // Correct field - Jonathan
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ row: userRow, col: userCol, value: num }),
          });

          const result = await response.json();
          console.log(result.correct);

          if (!previousValue || previousValue !== num.toString()) {
            // Record the move in the history if the previous value was empty or different
            moveHistory.push({
              row: userRow,
              col: userCol,
              previousValue: previousValue, // Save the previous value for accurate undo
              newValue: num,
              correct: result.correct,
            });
          }

          selectedCell.classList.remove("selected"); // Deselect the cell after filling
          selectedCell = null; // Reset the selected cell

          validateBoard(); // Validate the board after filling in a number
        } else {
          alert("Please select a cell first.");
        }
      }

      // Jan 
      // Function to check solution of the board
      async function checkSolution() {
        const puzzleSize = parseInt(document.getElementById("puzzleSize").value);
        const solution = [];

        for (let i = 0; i < puzzleSize; i++) {
          const row = [];
          for (let j = 0; j < puzzleSize; j++) {
            const cell = document.querySelector(
              `.cell[data-row="${i}"][data-col="${j}"]`
            );
            if (cell) {
              const value = parseInt(cell.value) || 0;
              row.push(value);
            } else {
              row.push(0);
            }
          }
          solution.push(row);
        }

        const response = await fetch("/check_solution", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ solution: solution }),
        });

        const result = await response.json();

        if (result.status === "correct") {
          alert("Sudoku has been solved!");
          stopTimer(); // Stop the timer when the solution is correct
          gameSolved = true; // Set the flag to indicate the game is solved
        } else {
          alert("Incorrect solution.");
        }
      }

      // Jan
      // Function to load a new game on the screen
      async function newGame() {
        const difficulty = document.getElementById("difficulty").value;

        const puzzleSize = document.getElementById("puzzleSize").value; // Get the selected puzzle size

        // Get the existing session_id from localStorage if it exists
        const existingSessionId = localStorage.getItem('session_id'); 

        // Request for a new game (pass the existing session_id if available)
        const response = await fetch(
          `/new_game?difficulty=${difficulty}&size=${puzzleSize}&session_id=${existingSessionId}`
        );
  
        const { puzzle, session_id } = await response.json();

        // Store the new session_id in localStorage for future use
        localStorage.setItem('session_id', session_id);
        
        /*const response = await fetch(
          `/new_game?difficulty=${difficulty}&size=${puzzleSize}`
        );

        const { puzzle } = await response.json();*/
        console.log(puzzle);
        console.log(session_id);
        updateGrid(puzzle);

        // Reset the mistake counter
        mistakeCount = 0;
        document.getElementById(
          "mistake-counter"
        ).textContent = `Mistakes: ${mistakeCount}/3`;

        resetTimer();
        moveHistory = [];
      }

      // Jan
      // Function to give the border colors of the grids & creating a checker pattern
      function updateBorders() {
        const isDarkMode = document.body.classList.contains("dark-mode"); // takes into account dark mode as well
        const borderColor = isDarkMode ? "rgb(255, 196, 33)" : "black";

        document.querySelectorAll(".cell").forEach((cell) => {
          const row = parseInt(cell.dataset.row);
          const col = parseInt(cell.dataset.col);
          const gridSize = Math.sqrt(document.querySelectorAll(".cell").length);
          const subGridSize = Math.sqrt(gridSize); // determine sub-grid size

          if (row % subGridSize === 0) {
            // update border colors for sub-grid separators
            cell.style.borderTop = `2px solid ${borderColor}`;
          }
          if (col % subGridSize === 0) {
            cell.style.borderLeft = `2px solid ${borderColor}`;
          }
          if ((row + 1) % subGridSize === 0) {
            cell.style.borderBottom = `2px solid ${borderColor}`;
          }
          if ((col + 1) % subGridSize === 0) {
            cell.style.borderRight = `2px solid ${borderColor}`;
          }
        });
      }

      // Jan
      // Function that updates the status of the grid
      function updateGrid(puzzle) {
        const size = puzzle.length;
        const grid = document.getElementById("sudoku-grid");
        const subGridSize = Math.sqrt(size);
        const cellSize = size === 16 ? "30px" : size === 9 ? "40px" : "50px"; // adjusts cells size based on grid size

        grid.style.gridTemplateRows = `repeat(${size}, ${cellSize})`; // sets up CSS grid with the appropriate size
        grid.style.gridTemplateColumns = `repeat(${size}, ${cellSize})`;
        grid.innerHTML = ""; // clears the existing grid

        for (let row = 0; row < size; row++) {
          // generates cells dynamically
          for (let col = 0; col < size; col++) {
            const cell = document.createElement("input");
            cell.type = "text";
            cell.classList.add("cell");
            cell.dataset.row = row;
            cell.dataset.col = col;
            cell.value = puzzle[row][col] || "";
            if (puzzle[row][col]) { // marks pre-filled cells
              cell.disabled = true;
              cell.dataset.preFilled = "true";
              cell.style.fontWeight = "bold";
            } else {
              cell.dataset.preFilled = "false";
            }
            cell.style.textAlign = "center";
            cell.style.width = cellSize;
            cell.style.height = cellSize;
            grid.appendChild(cell);
          }
        }
        moveHistory = []; // reset move history

        updateNumberButtons(size); // adjusts number buttons based on grid size

        document.querySelectorAll(".cell").forEach((cell) => {
          // function to handle cell selection (remains largely the same)
          cell.addEventListener("click", () => {
            document // deselect previously selected cell, if any
              .querySelectorAll(".cell")
              .forEach((c) => c.classList.remove("selected"));
            cell.classList.add("selected"); // mark the clicked cell as selected
            selectedCell = cell;
          });
        });

        enforceMaxLength();
        updateBorders();
      }

      // Jan
      // Function to generate number buttons based on the grid size
      function updateNumberButtons(size) {
        const buttonContainer = document.querySelector(".number-controls");
        buttonContainer.innerHTML = ""; // clear existing buttons
        const maxNumber = size === 16 ? 16 : size === 9 ? 9 : 4; // determine the range of numbers based on grid size

        for (let i = 1; i <= maxNumber; i++) {
          // generate buttons from 1 to maxNumber
          const button = document.createElement("button");
          button.textContent = i;
          button.onclick = () => selectNumber(i); // Assign the number when clicked
          buttonContainer.appendChild(button);
        }
      }

      // Jan
      // Light & Dark Mode Button Functionality
      function toggleTheme() {
        const body = document.body;
        const themeToggleButton = document.getElementById("theme-toggle");

        body.classList.toggle("dark-mode"); // toggle the dark-mode class on the body

        if (body.classList.contains("dark-mode")) {
          // update the button text based on the current theme
          themeToggleButton.textContent = "Light Mode";
          localStorage.setItem("theme", "dark");
        } else {
          themeToggleButton.textContent = "Dark Mode";
          localStorage.setItem("theme", "light");
        }

        updateBorders();
      }

      // Jan
      // Function to enforece the input of a cell to be only one value
      function enforceMaxLength() {
        const cells = document.querySelectorAll(".cell"); // select all input cells
        cells.forEach((cell) => {
          cell.setAttribute("maxlength", "1"); // enforce maxlength
        });
      }

      document.querySelectorAll(".cell").forEach((cell) => {
        cell.addEventListener("input", () => {
          // listen for direct keyboard input in each cell
          const row = cell.dataset.row;
          const col = cell.dataset.col;
          const newValue = cell.value;
          const gridSize = Math.sqrt(document.querySelectorAll(".cell").length); // get the grid size for validation

          if (
            // validate the input (e.g., number within range)
            newValue &&
            !isNaN(newValue) &&
            newValue >= 1 &&
            newValue <= gridSize
          ) {
            const previousValue = cell.dataset.previousValue || ""; // captures the previous value from the cell's dataset
            const correct = current_solution[row][col] == newValue; // determines if the new value is correct

            moveHistory.push({
              // add the move to the move history
              row: row,
              col: col,
              previousValue: previousValue,
              newValue: newValue,
              correct: correct,
            });

            console.log("Move recorded:", moveHistory);
            cell.dataset.previousValue = newValue; // update the `previousValue` attribute for next time

            validateBoard(); // revalidate the board after the move
          } else {
            cell.value = ""; // Clear invalid input
            alert(`Please enter a number between 1 and ${gridSize}.`);
          }
        });
      });

      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          if (!isPaused) {
            // tab becomes inactive
            stopTimer(); // stop the timer if the game is not paused
          }
        } else {
          if (!isPaused) {
            // tab becomes active again
            startTimer(); // resume the timer only if the game is not paused
          }
        }
      });

      window.onload = () => {
        enforceMaxLength(); // enforce maximum length of values per cell
        if (localStorage.getItem("theme") === "dark") {
          // make sure theme works
          document.body.classList.add("dark-mode");
          document.getElementById("theme-toggle").textContent = "Light Mode";
        } else {
          document.body.classList.add("light-mode");
          document.getElementById("theme-toggle").textContent = "Dark Mode";
        }
        startTimer(); // start timer on window load
      };
    </script>
  </body>
</html>
